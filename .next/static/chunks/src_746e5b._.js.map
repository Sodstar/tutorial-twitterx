{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/sodstar/development/web/frontend/x/src/actions/product.action.tsx"],"sourcesContent":["\"use server\";\n\nimport { connectDB } from \"@/lib/mongoose\";\nimport { Products } from \"@/models/productMongo\";\nimport { revalidatePath, unstable_cache } from \"next/cache\";\nimport { logger } from \"@/lib/logger\";\n\nexport const getCachedProducts = unstable_cache(async () => {\n  try {\n    await connectDB();\n    const products = await Products.find({});\n    return products;\n  } catch (error) {\n    logger.error(\"Error fetching products:\", error);\n    throw new Error(\"Failed to fetch products\");\n  }\n}, [\"products\"], { revalidate: 1 });\n\nexport async function getProductById(productId: string) {\n  try {\n    await connectDB();\n    const product = await Products.findById(productId);\n    if (!product) throw new Error(\"Product not found\");\n    return product;\n  } catch (error) {\n    logger.error(`Error fetching product ID ${productId}:`, error);\n    throw new Error(\"Failed to fetch product\");\n  }\n}\n\nexport async function checkExistingProduct(name: string) {\n  try {\n    await connectDB();\n    return await Products.findOne({ name });\n  } catch (error) {\n    logger.error(`Error checking existing product ${name}:`, error);\n    throw new Error(\"Failed to check product existence\");\n  }\n}\n\nexport async function createProduct(name: string, price: number, description: string) {\n  try {\n    await connectDB();\n\n    const existingProduct = await checkExistingProduct(name);\n    if (existingProduct) throw new Error(\"Product already exists\");\n\n    const newProduct = new Products({ name, price, description });\n    await newProduct.save();\n\n    revalidatePath(\"/products\");\n\n    logger.info(`Product created: ${name}`);\n    return newProduct;\n  } catch (error) {\n    logger.error(\"Error creating product:\", error);\n    throw new Error(\"Failed to create product\");\n  }\n}\n\nexport async function updateProduct(productId: string, updateData: Partial<{ name: string; price: number; description: string }>) {\n  try {\n    await connectDB();\n    const updatedProduct = await Products.findByIdAndUpdate(productId, updateData, { new: true });\n\n    if (!updatedProduct) throw new Error(\"Product not found\");\n\n    // Revalidate cache\n    revalidatePath(\"/products\");\n\n    logger.info(`Product updated: ${productId}`);\n    return updatedProduct;\n  } catch (error) {\n    logger.error(`Error updating product ID ${productId}:`, error);\n    throw new Error(\"Failed to update product\");\n  }\n}\n\nexport async function deleteProduct(productId: string) {\n  try {\n    await connectDB();\n    const deletedProduct = await Products.findByIdAndDelete(productId);\n    \n    if (!deletedProduct) throw new Error(\"Product not found\");\n\n    revalidatePath(\"/products\");\n\n    logger.info(`Product deleted: ${productId}`);\n    return deletedProduct;\n  } catch (error) {\n    logger.error(`Error deleting product ID ${productId}:`, error);\n    throw new Error(\"Failed to delete product\");\n  }\n}"],"names":[],"mappings":";;;;;;;;;;IAOa;IAWS;IAYA;IAUA;IAoBA;IAkBA"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///Users/sodstar/development/web/frontend/x/src/app/products/page.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { useState, useEffect } from \"react\";\nimport {\n  Card,\n  CardContent,\n  CardFooter,\n  CardTitle,\n  CardDescription,\n} from \"@/components/ui/card\"; // Assuming you have shadcn components\nimport { getCachedProducts } from \"@/actions/product.action\";\nimport toast from \"react-hot-toast\";\nimport { IProduct } from \"@/models/productMongo\";\n\n// type Products = Awaited<ReturnType<typeof getCachedProducts>>;\n\nconst page = () => {\n  const [products, setProducts] = useState<IProduct[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchNotifications = async () => {\n      setIsLoading(true);\n      try {\n        const data = await getCachedProducts();\n        setProducts(data);\n      } catch (error) {\n        toast.error(\"Failed to fetch notifications\");\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchNotifications();\n  }, []);\n\n  if (isLoading) return <div>Loading...</div>;\n\n  return (\n    <div>\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-8\">\n        <div>1</div>\n        <div>1</div>\n        <div>1</div>\n        <div>1</div>\n      </div>\n    </div>\n  );\n}\n\nexport default page;\n"],"names":[],"mappings":";;;;AAEA;AAQA;AACA;;;AAXA;;;;AAcA,iEAAiE;AAEjE,MAAM,OAAO;;IACX,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAc,EAAE;IACvD,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAE3C,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;0BAAE;YACR,MAAM;qDAAqB;oBACzB,aAAa;oBACb,IAAI;wBACF,MAAM,OAAO,MAAM,CAAA,GAAA,uIAAA,CAAA,oBAAiB,AAAD;wBACnC,YAAY;oBACd,EAAE,OAAO,OAAO;wBACd,0JAAA,CAAA,UAAK,CAAC,KAAK,CAAC;oBACd,SAAU;wBACR,aAAa;oBACf;gBACF;;YAEA;QACF;yBAAG,EAAE;IAEL,IAAI,WAAW,qBAAO,6LAAC;kBAAI;;;;;;IAE3B,qBACE,6LAAC;kBACC,cAAA,6LAAC;YAAI,WAAU;;8BACb,6LAAC;8BAAI;;;;;;8BACL,6LAAC;8BAAI;;;;;;8BACL,6LAAC;8BAAI;;;;;;8BACL,6LAAC;8BAAI;;;;;;;;;;;;;;;;;AAIb;GAhCM;uCAkCS"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}